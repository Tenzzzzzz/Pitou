[{"content":"[REV] EAAS We are given an ELF file that encrypts our input data in some way Also an encrypted_string-\u0026gt;\u0026ldquo;CAS{Y6oduOh_X3_gQu3xn6t_EXF_J3vxhf_Ca_3yM7zln}\u0026rdquo;\nIt seems that the index of input characters does not affect the encryption algorithm Here is the encryption function\nit take char by char in rax register then pass it as paramter to shift_char function\nthis the encryption algorithm , it is one to one encryptin We can brute force the program by trying all possible ASCII characters to see what matches the encrypted flag\nHere is a simple script to accomplish that import subprocess\rflag=[]\rdef run_with_inp(inp):\rprocess = subprocess.Popen(\r[\u0026#39;/home/kali/EAAS\u0026#39;],\rstdin=subprocess.PIPE,\rstdout=subprocess.PIPE,\rstderr=subprocess.PIPE,\rtext=True\r)\rprocess.stdin.write(inp)\rprocess.stdin.flush()\routput, _ = process.communicate(timeout=5)\rreturn output[output.find(\u0026#39;Encrypted:\u0026#39;):]\rinp = \u0026#39;\u0026#39;\rtarget = [0x43, 0x41, 0x53, 0x7b, 0x59, 0x36, 0x6f, 0x64, 0x75, 0x4f, 0x68, 0x5f, 0x58, 0x33, 0x5f, 0x67, 0x51, 0x75, 0x33, 0x78, 0x6e, 0x36, 0x74, 0x5f, 0x45, 0x58, 0x46, 0x5f, 0x4a, 0x33, 0x76, 0x78, 0x68, 0x66, 0x5f, 0x43, 0x61, 0x5f, 0x33, 0x79, 0x4d, 0x37, 0x7a, 0x6c, 0x6e, 0x7d, 0x0a]\rdef replace_letter(word, index, new_letter):\rreturn word[:index] + new_letter + word[index+1:]\rfor i in range(47):\rfor j in range(32, 128):\rinp = replace_letter(inp, len(inp)-1, chr(j))\rres = run_with_inp(inp)[len(\u0026#34;Encrypted: \u0026#34;):-1]\rtrue_res = chr(target[i])\r#print(res, \u0026#39; VS \u0026#39;, true_res)\rif true_res!=res:\rcontinue\relse:\rprint(chr(j))\rflag.append(chr(j))\rprint(\u0026#39;\u0026#39;.join(flag)) YAO{W3lcoMe_T0_aNo0th3r_CTF_H0sted_By_0xL4ugh}\n","parent":"Ctfs Writeups","permalink":"/blog/ctfs-writeups/1/","section":"blog","summary":"[REV] EAAS We are given an ELF file that encrypts our input data in some way Also an encrypted_string-\u0026gt;\u0026ldquo;CAS{Y6oduOh_X3_gQu3xn6t_EXF_J3vxhf_Ca_3yM7zln}\u0026rdquo;\nIt seems that the index of input ","title":"AswanCTF 2025 Finals"},{"content":"","parent":"Take A l00k","permalink":"/blog/ctfs-writeups/","section":"blog","summary":"","title":"Ctfs Writeups"},{"content":"Program Link ‚áíhttps://crackmes.one/crackme/6848e4102b84be7ea77437ba\nSo we are provided with an exe and a PCAP file\nI will start by performing some static analysis of the .exe file to see what it has.\nMany tools are used for this purpose, but the one that is most reliable for me is DIE.\nAs I see in the result, an unpacked C program that uses the OpenSSL library, which indicates that the malware uses some sort of cryptography functions, which makes sense, since it is ransomware.\ni will do an extra step and scan the program again with PEstudio, which gives us a detailed static analysis of PE files.\nWe see in the imports section many suspicious functions like DeleteFileA, WSAStartup, connect, send, and other functions related to network communication, which indicates that the ransomware communicates with C2, maybe. I will see.\nNow I will use the floss tool that will reveal program‚Äôstrings\nIP and a path ??, interesting.\nNow I will load the program in IDA to reverse it.\nWe begin by looking at the main function and see what is being called from there.\nI want to explore these functions.\nLet‚Äôs start with the sub_001860() function.\nI see a LoadLibrary function, which is used obviously to load DLLs. LoadLibrary loads a DLL into the process‚Äôs memory and returns an hmodule, which is simply the base address of the loaded module.\nThen the program allocates a 0x20-byte block, which will be filled later with some data as we continue exploring the function.\nNow the program uses a getprocaddress function, which, if you do not know, is a function that gets the address of a function from a DLL.\nThen the program calls that weird get_from_file function with a parameter called ‚Äúanonymous‚Äù, it then writes the result to the previously initialized block and returns that block.\nAgain same approach, it gets the address of another weird function, get_result_bytes, and calls it with a block argument, then returns that block, so it fills that block with some data, which we still do not know what these data are going to be used for.\nstill getting some function named gen, opening a file called anonymous, allocating some space to read the content of the file, and calling the function gen with file content and size arguments, and then returning the block.\nNote the fseek/ftell/rewind part. It is used to get the file size.\nfseek with 0,2 argument moves the file pointer to the end of the file,ftell returns the current offset of the pointer, rewind moves the pointer back to the beginning of the file.\nRefer to that for more info\nSo final observation on this function, it just tries to read some data from different things, and whichever gets the job done, will return first, starting from\n1-gen_from_file function\n2-get_result_bytes function\n3-gen function\nMaybe these data are keys or something that will be used for encryption later ?? idk but we will continue exploring the other functions, and btw it is a recommended approach to rename vars, function names, and write some comments in functions so it is clearer and representative of the functionalities. I tend to write long names that are very descriptive. something like that ‚Üí\nNow we explore the sub_001DE1 function‚Üí\nHere it is‚Ä¶\nafter some renaming ..\nNow I will explore the sub_001668 function to see what it does.\ngot two functions..\nThe first function seems to do some operations :\nif u are a new to ctfs u may wonder what does this do, but i have seen this function many times before, it is part of the rc4 algorithm, which is used for data encryption/decryption, and btw RC4 is not used now in applications cuz it has many vulnerabilities , another important thing , when i said i saw this form before , i meant that in a high level , like my eye just suspected that i saw it before in rc4 kSA, maybe i am wrong, maybe not ‚Ä¶. this is an important concept in RE, we do introduce hypothesis about some part of the program, then we try to test our understanding if it is correct or not ,so we will see.\nThe second function does the PRNG and encrypts the data inside the file\nNow, after the ransomware encrypted that file, it deleted it and now tries to communicate with the C2‚Ä¶\nThe ransomware tries to connect to the C2 server with IP=192.168.134.132 and port 8888, then it sends the size of encrypted data to it, and then the data itself.\nnow moving to the second function sub_001FB3..\ndoes the same as the previous function, but instead of using RC4, it uses AES with a key (sha256(‚Äùhackingisnotcrime‚Äù)), and it encrypts the libgen.dll.\nNow I will summarize my understanding of that ransomware.\n1. The ransomware loads some data from a file named ‚Äúanonymous‚Äù using three different methods. Each method is a function that receives the file as input, and whichever method succeeds first returns the result.\n2. The program encrypts an important file called ‚Äúusr.html‚Äù and a DLL named libgen.dll. The DLL is used to retrieve functions that read data from the anonymous file, which is later used during encryption.\n3-After encryption, the ransomware sends the encrypted files to a C2 server and then deletes the original files.\nWe now need to examine the PCAP file to retrieve these files and decrypt the user.html file as well.\nI see a GET request to the anonymous file and a response with that file ‚Üí\nHere is the response with the file bytes‚Üí\nFollowing that, I see a packet with data length 4 bytes, and this data represents the length of the sent file (user.html), I think.\nThis is 2588 bytes.\nThen, following this packet, we got two packets with data length =2588, representing the user\u0026rsquo;s HTML file.\nI also got the packets of the DLL file, which is 16912 bytes.\nNow we have the three files we need‚Üí\nFirst, i will decrypt the library since I have the key ‚áí sha256(.‚Äùhackingisnotacrime\u0026quot;)\nNow, to be sure that I extract the key from the anonymous file correctly, I will debug the function that gets data from that file in ida‚Üí\nIt is obviously not safe to run/debug a program that is supposly a malware on your main machine but i do debug malwares on my main windows machine cuz I‚Äôm not a coward üí™\nThe author implemented a simple anti-debug check that will cause the program to exit, but I will bypass that easily\nNow we are here\nI then created those same paths, with intended files, until the rc4/decryption\nNote that RC4 is a symmetric stream cipher, which means encryption and decryption use the exact same process.\nThe same key generates the same keystream, so applying RC4 twice with the same key restores the original plaintext.\nHere is the flag‚Üí\nAnother approach is to directly load the dll, call the intended functions from it to generate the key, and then decrypt the user\u0026rsquo;s HTML file using it.\n","parent":"Crackmes challenges","permalink":"/blog/crackmes/1/","section":"blog","summary":"Program Link ‚áíhttps://crackmes.one/crackme/6848e4102b84be7ea77437ba\nSo we are provided with an exe and a PCAP file\nI will start by performing some static analysis of the .exe file to see what it has.\n","title":"Ransomware"},{"content":"[REV][Rainbom Bash Adventure] We are given a game called Rainbombashadventure, made with a game engine called Ren\u0026rsquo;Py\nRen\u0026rsquo;Py\nAfter escaping a long conversation between characters, I had to choose paths to clouds, given the distances, the win/lose condition is determined based on my choices\nI will explore the game folder the script.rpy file contains the whole game logic including win or lose conditions\nThis is cloud0 menu, which displays the distances between it and the others, same for the rest of the clouds\nIt is a Travelling Salesman Problem\nTSP\nAnd here is the important part that determines our win condition-\u0026gt;\nlabel ending:\rpython:\rimport hashlib\rflag = b\u0026#34;\u0026#34;\rdef xor(target, key):\rout = [c ^ key[i % len(key)] for i, c in enumerate(target)]\rreturn bytearray(out)\rdef key_from_path(path):\rreturn hashlib.sha256(str(path).encode()).digest()\rdef check_path(path, enc_flag):\rglobal flag\rflag1 = xor(enc_flag, key_from_path(path))\rflag2 = xor(enc_flag, key_from_path(list(reversed(path))))\rif flag1.startswith(b\u0026#34;BtSCTF\u0026#34;):\rflag = flag1\rprint(flag)\rflag = bytes(flag).replace(b\u0026#34;{\u0026#34;, b\u0026#34;{{\u0026#34;).decode(\u0026#39;ascii\u0026#39;)\rreturn True\rif flag2.startswith(b\u0026#34;BtSCTF\u0026#34;):\rflag = flag2\rprint(flag)\rflag = bytes(flag).replace(b\u0026#34;{\u0026#34;, b\u0026#34;{{\u0026#34;).decode(\u0026#39;ascii\u0026#39;)\rreturn True\rreturn False\ris_correct = check_path(nodes, bytearray(b\u0026#39;\\xc2\\x92\\xf9\\xf66\\xe8\\xa5\\xa6\\x17\\xb6mGE\\xcfQ\\x90Mk:\\x9a\\xbb\\x905\u0026amp;\\x19\\x8e\\xc4\\x9a\\x0b\\x1f\\xf8C\\xf4\\xb9\\xc9\\x85R\\xc2\\xbb\\x8d\\x07\\x94[R_\\xf5z\\x9fAl\\x11\\x9c\\xbb\\x9255\\x08\\x8e\\xf6\\xd6\\x04\u0026#39;))\rif is_correct:\rrb \u0026#34;all cloudz smashed im the queen\u0026#34;\rrb \u0026#34;i got 100% swag\u0026#34;\r\u0026#34;[flag]\u0026#34;\relse:\r\u0026#34;Sadly, Rainbom Bash was too slow and wasn\u0026#39;t able to smash all clouds.\u0026#34;\rreturn The program decrypts the flag with the path (nodes) chosen, so the right path will successfully decrypt the flag!\nbtw, Travelling salesman problem is an np hard problem, which means it can not be solved in polynomial time, but for a small number of nodes, it can be solved (not guaranteed) using a greedy algorithm\nsolver like this may work -\u0026gt; https://github.com/dmishin/tsp-solver\nBut first, we need to extract the matrix of distances between clouds. I wrote a simple regex to grab and add it to the matrix\nimport re\rimport numpy as np\rdef get_the_distance_of_nodes(code):\rdebu=[]\rdistance=np.zeros((20,20))\rfor clound_num in range(20):\rregex_for_spilt = f\u0026#34;label cloud{clound_num}\u0026#34;\rsplitawy_first_position=re.search(regex_for_spilt, code)\rif splitawy_first_position:\rstart_pos=splitawy_first_position.start()\rif clound_num \u0026lt; 19:\rend_pattern = f\u0026#34;label cloud{clound_num + 1}:\u0026#34;\rend_match = re.search(end_pattern, code)\rif end_match:\rend_pos = end_match.start()\relse:\rend_pos = len(code)\relse:\rend_pattern = \u0026#34;label ending:\u0026#34;\rend_match = re.search(end_pattern, code)\rif end_match:\rend_pos = end_match.start()\relse:\rend_pos = len(code)\rsection_text = code[start_pos:end_pos]\rregex_for_label=re.compile(r\u0026#39;label cloud (\\d)\u0026#39;)\r#regex_for_distance=re.compile(r\u0026#39;(\\d)\\spony\u0026#39;)\rregex_for_cloudy=re.compile(r\u0026#39;cloud(\\d*) which is (\\d*) pony units\u0026#39;)\rc_d=regex_for_cloudy.findall(section_text)\rn_c=regex_for_label.findall(section_text)\r#print(c_d)\rfor c in c_d:\r#this is only for debugging\rdebu.append(clound_num)\rdistance[clound_num,int(c[0])]=int(c[1])\rif(int(c[1]))==0:\r#debugging\rprint(f\u0026#34;cloud_num={clound_num},to which cloud = {int(c[0])},distance = {int(c[1])}\u0026#34;)\rreturn distance,debu now using the mentioned library to solve it -\u0026gt;\nfrom tsp_solver.greedy import solve_tsp\rprint(\u0026#34;the path is - \u0026gt; \u0026#34;)\rpath=solve_tsp(r,endpoints=(0,0))\rprint(path) path is : [0, 12, 15, 2, 1, 5, 11, 14, 17, 7, 19, 13, 9, 10, 3, 8, 16, 18, 4, 6, 0]\nNow, replicate the code in the game file to decrypt the flag\ndef xor(target, key):\rout = [c ^ key[i % len(key)] for i, c in enumerate(target)]\rreturn bytearray(out)\rdef key_from_path(path):\rreturn hashlib.sha256(str(path).encode()).digest()\renc_flag = bytearray(\rb\u0026#39;\\xc2\\x92\\xf9\\xf66\\xe8\\xa5\\xa6\\x17\\xb6mGE\\xcfQ\\x90Mk:\\x9a\\xbb\\x905\u0026amp;\\x19\\x8e\\xc4\\x9a\\x0b\\x1f\\xf8C\\xf4\\xb9\\xc9\\x85R\\xc2\\xbb\\x8d\\x07\\x94[R_\\xf5z\\x9fAl\\x11\\x9c\\xbb\\x9255\\x08\\x8e\\xf6\\xd6\\x04\u0026#39;)\rpath = [0, 12, 15, 2, 1, 5, 11, 14, 17, 7, 19, 13, 9, 10, 3, 8, 16, 18, 4, 6, 0]\rpath_rev=path[::-1]\rflag1 = xor(enc_flag, key_from_path(path))\rflag2 = xor(enc_flag, key_from_path(path_rev))\rif flag1.startswith(b\u0026#34;BtSCTF\u0026#34;):\rprint(flag1.decode(\u0026#39;ascii\u0026#39;))\relif flag2.startswith(b\u0026#34;BtSCTF\u0026#34;):\rprint(flag2.decode(\u0026#39;ascii\u0026#39;)) BtSCTF{YOU_are_getting_20_percent_c00ler_with_this_one_!!_B)}\n[REV][TRANSLATOR] We are given an ELF file and an encrypted flag: ÂπæÊπÇÊΩåËïî‰©òÊ°¢Ë±ùË©ß‰≠°‰ùµÊïØ‰°®Ââ±Êåß‰ç©Á°∑Á©èÁΩ£„à°‰®•Ë¥á\nThe program encrypts our input, and after some interaction with it, I found that,\n1-every two characters produce one encrypted character, and if u input one character only, it will also produce one encrypted character\n2-it is position dependent It seems that the last input characters are encrypted without getting affected by position, before that, it is affected\nLet\u0026rsquo;s examine the program in depth using IDA\nThe program takes the input as the second argument, pointed to by the v3 pointer. The program loads 2 bytes each time, then calls the main function, which holds the encryption algorithm It seems like function sub_1270 does something to (v3 + 1, which holds the second char of the input parameter to the main function, then the return will be used in encryption.\nI examined the sub_1270 function, and it works as follows:\nso if the first byte is found , it does return first byte\u0026gt;\u0026gt;4\rif second byte is found , return second byte \u0026gt;\u0026gt;4 + first byte \u0026gt;\u0026gt;4\rif third byte is found , return third byte \u0026gt;\u0026gt; 4 + second byte \u0026gt;\u0026gt;4 + first byte \u0026gt;\u0026gt;4\rif fourth byte is found , return fourth byte \u0026gt;\u0026gt; 4 + the rest\rif more than that , it will recursively return the summation of following bytes shifted right by 4 the enryption algorithm - \u0026gt; the main shifting algorithm\rv6 is first char\rv4 is output of function sub_1270 v5 +1 is my second char\rthe encryption is -\u0026gt;\rhigh_byte = (first_byte \u0026amp; 0xF0) | ((first_byte + ((function_output + (first_byte \u0026gt;\u0026gt; 4)) \u0026gt;\u0026gt; 4)) \u0026amp; 0x0F)\rlow_byte = (second_byte \u0026amp; 0xF0) | ((second_byte + function_output + (first_byte \u0026gt;\u0026gt; 4)) \u0026amp; 0x0F)\runicode = (high_byte \u0026lt;\u0026lt; 8) + low_byte + 4096 So from here, we understand that the first bytes of input will be affected, cause of the function sub_1270 We know the last char is \u0026lsquo;}\u0026rsquo;\nthat encrypted char is the last one in the given encrypted text\nSo we can brute force the program using this knowledge as a starting point\nBeginning from the reverse order, we‚Äôll incrementally reconstruct the flag, testing two characters every time\nimport time\rfrom pwn import *\rdef solvey(right_data):\rflag_till_now = \u0026#34;}\u0026#34;\rstart_index=len(right_data)-2\rfor i in range(20):\rmatch=False\rfor first_byte in range(33, 126):\rif match ==True:\rbreak\rfor second_byte in range(33, 126):\rtry_that=chr(first_byte) + chr(second_byte)+flag_till_now\rp = process([\u0026#39;./translator\u0026#39;, try_that])\routput = p.recvall().decode().strip()\rprint (\u0026#34;output - \u0026gt; \u0026#34;,output,\u0026#34;length of output- \u0026gt; \u0026#34;,len(output))\rprint(\u0026#34;right_data = \u0026#34;,right_data[start_index:],\u0026#34;length of right data - \u0026gt; \u0026#34;,len(right_data[start_index:]))\rif output == right_data[start_index:]:\rprint(\u0026#34;hi , we found it\u0026#34;)\rprint(chr(first_byte) + chr(second_byte) + flag_till_now)\rflag_till_now = chr(first_byte) + chr(second_byte) + flag_till_now\rstart_index=start_index-1\rmatch=True\rbreak\relse:\rmatch=False\rcontinue\rif not match:\r#debug\rprint(\u0026#34;No match\u0026#34;)\rtime.sleep(100)\rreturn flag_till_now\rtrue_data=\u0026#34;ÂπæÊπÇÊΩåËïî‰©òÊ°¢Ë±ùË©ß‰≠°‰ùµÊïØ‰°®Ââ±Êåß‰ç©Á°∑Á©èÁΩ£„à°‰®•Ë¥á\u0026#34;\rflag=solvey(true_data)\rprint(flag) This method will take about an hour or something. Another fast approach is to use a hybrid approach between brute-forcing and implementing the same encryption algorithm :\ndef decodeer(unicode_chars):\rascii_chars = [\u0026#34;}\u0026#34;]\rfollowing_high_nibbles = [\u0026#34;}\u0026#34;]\rfor i in range(len(unicode_chars) - 1, -1, -1):\runicode_val = unicode_chars[i]\rresult = brute_force_decode(unicode_val, following_high_nibbles)\rif result:\rfirst_byte, second_byte = result\rfollowing_high_nibbles.insert(0, chr(second_byte))\rfollowing_high_nibbles.insert(0, chr(first_byte))\rascii_chars.insert(0, chr(second_byte))\rascii_chars.insert(0, chr(first_byte))\rreturn \u0026#39;\u0026#39;.join((b) for b in ascii_chars)\rdef brute_force_decode(unicode_val, following_high_nibbles):\rval = unicode_val - 4096\rvalinbinary = format(val, \u0026#39;016b\u0026#39;)\rprint(\u0026#34;val in binary\u0026#34;, valinbinary, \u0026#34;len(valinbinary)=\u0026#34;, len(valinbinary))\rhigh_byte = (val \u0026gt;\u0026gt; 8) \u0026amp; 0xFF\rprint(\u0026#34;high_byte in binary=\u0026#34;,format(high_byte, \u0026#39;08b\u0026#39;))\rlow_byte = val \u0026amp; 0xFF\rprint(\u0026#34;low byte in binary=\u0026#34;,format(low_byte, \u0026#39;08b\u0026#39;))\rfor first_byte in range(32,128):\rfor second_byte in range(32,128):\rtmp=[chr(second_byte)]+following_high_nibbles\rfunction_output = calculate_function_output(tmp)\rif check_encoding(first_byte, second_byte, function_output, high_byte, low_byte):\r#print(f\u0026#34;we found the first-\u0026gt; {chr(first_byte)} and the second byte -\u0026gt; {chr(second_byte)}\u0026#34;)\rprint(\u0026#34;second byte\u0026#34;, chr(second_byte), end=\u0026#39;\u0026#39;)\rprint(\u0026#34; , first byte\u0026#34;,chr(first_byte),\u0026#34;\\n\u0026#34;)\rreturn first_byte, second_byte\rreturn None\rdef check_encoding(first_byte, second_byte, function_output, target_high, target_low):\rcalc_high = (first_byte \u0026amp; 0xF0) | ((first_byte + ((function_output + (first_byte \u0026gt;\u0026gt; 4)) \u0026gt;\u0026gt; 4)) \u0026amp; 0x0F)\rcalc_low = (second_byte \u0026amp; 0xF0) | ((second_byte + function_output + (first_byte \u0026gt;\u0026gt; 4)) \u0026amp; 0x0F)\rreturn calc_high == target_high and calc_low == target_low\rdef calculate_function_output(second_char_till_end):\rif not second_char_till_end:\rreturn 0\rhigh_nibbles = [ord(b) \u0026gt;\u0026gt; 4 for b in second_char_till_end]\rreturn sum(high_nibbles)\rdef decode():\rmessage = \u0026#34;ÂπæÊπÇÊΩåËïî‰©òÊ°¢Ë±ùË©ß‰≠°‰ùµÊïØ‰°®Ââ±Êåß‰ç©Á°∑Á©èÁΩ£„à°‰®•\u0026#34;\r#print(len(message))\runicode_values = [ord(c) for c in message]\r#print(len(unicode_values))\rascii_message = decodeer(unicode_values)\rprint(f\u0026#34;Decoded flag: {ascii_message}\u0026#34;)\rdecode() BtSCTF{W0W_it_re4l1ym3aNs$0methIng!!:)}\n","parent":"Ctfs Writeups","permalink":"/blog/ctfs-writeups/2/","section":"blog","summary":"[REV][Rainbom Bash Adventure] We are given a game called Rainbombashadventure, made with a game engine called Ren\u0026rsquo;Py\nRen\u0026rsquo;Py\nAfter escaping a long conversation between characters, I had to ","title":"Break The Syntax ctf 2025"},{"content":"I‚Äôve decided to share here the interesting Crackmes that I come across. Unlike typical CTF write-ups, which are often quick and straight to the point, my goal here is to document every detail of the challenge in a structured and teaching-oriented way.\n","parent":"Take A l00k","permalink":"/blog/crackmes/","section":"blog","summary":"I‚Äôve decided to share here the interesting Crackmes that I come across. Unlike typical CTF write-ups, which are often quick and straight to the point, my goal here is to document every detail of the c","title":"Crackmes challenges"},{"content":"I have participated along with my awesome team 0xD4WN and ranked fifth\nHere are the solutions to two reverse challenges, phantime and millionaire [REV][phantime] We are given a PE file\nDetect it easy\nUpon executing it -\u0026gt;\nIt just asks for a 4-character password (that is what we know until now)\nLet\u0026rsquo;s analyze it in IDA\nWe need to check the true data that our input is being compared to\nreading it from stack directly\nnow we got this -\u0026gt;\nLet\u0026rsquo;s explore the functions being called\nafter passing the first check, there are three functions being called\nfirst function is just opening a registry key and querying a value to get its data , which is irrelevant first function\nthird function creates a registry key, sets a value inside this registry with a name \u0026ldquo;Flagcontent\u0026rdquo; and sets its data with the string -\u0026gt; \u0026ldquo;This is not the flag you\u0026rsquo;re looking for\u0026rdquo;\nthird function\nsecond function is where we will get our solution\nThe function creates a random string, initializes a string called-\u0026gt; \u0026ldquo;MEOWMEOW\u0026rdquo; ,and it initializes an array called src with the values -\u0026gt;\ndata =[\r0x3D, 0x24, 0x3C, 0x24, 0x3A, 0x2A, 0x3D, 0x33,\r0x12, 0x31, 0x26, 0x3A, 0x24, 0x2B, 0x28, 0x08,\r0x2C, 0x31, 0x3B, 0x36, 0x2E, 0x2E, 0x10] Then, the random string is XORed with the string \u0026ldquo;MEOWMEOW\u0026rdquo;\nThe output of this operation is not used, so let\u0026rsquo;s continue exploring the function to get any clues Again, it creates a key and sets some values, with data and the key (MEOWMEOW), and so on\nWe should notice an interesting thing here, the memory location ExclusivePurri, contains -\u0026gt;\u0026ldquo;Exclusive purring helps decode secrets\u0026rdquo;, purring means the sound of a cat XD, that why i labeled the hardcoded string \u0026ldquo;MEOWMEOW\u0026rdquo; as a key, this statement gives a hint that the flag can be obtained by xoring some data with the key, another interesting thing is that, the placeholder takes the random string asthe last part of the flag Now we have a full picture of how the program works and how to get the flag\nlet\u0026rsquo;s xor the key with the extracted data\ndef decode(encoded_data, key):\rresult = \u0026#34;\u0026#34;\rfor i in range(len(encoded_data)):\rdecoded_byte = encoded_data[i]^ord(key[i % len(key)])\rresult += chr(decoded_byte)\rreturn result\rencoded_data = [\r0x3D, 0x24, 0x3C, 0x24, 0x3A, 0x2A, 0x3D, 0x33,\r0x12, 0x31, 0x26, 0x3A, 0x24, 0x2B, 0x28, 0x08,\r0x2C, 0x31, 0x3B, 0x36, 0x2E, 0x2E, 0x10\r]\rkey = \u0026#34;MEOWMEOW\u0026#34;\rdecoded = decode(encoded_data, key)\rprint(decoded) password_timing_attack_\nsecond part is the random string, so the flag is EGCTF{password_timing_attack_9nw5pa}\n[REV][millionaire] We are given a PE file\nTime to go to IDA\u0026hellip;\npart_of_main_function\nNownow we need to check the path_determining_function\nfirst part of the function\nThe function does call CryptStringToBinaryA function on string , then it xor the resulting bytes with our input key,\nIt then computes the sha256 hash of the resulting string from the previous operation, and compares it specific hash, The flag consists of two parts, the first part is the str1, which results from xoring the key with the bytes resulting from applying crypt_string_to_binary on that string \u0026ldquo;IAAA\u0026hellip;\u0026rdquo;\nnow, the problem is we do not know the intended result , we got only the hash (f4b\u0026hellip;.)\nif we go back a little bit , we notice that , the text that is printed when we execute the program, is hardcoded but encrypted\nthere is interesing two things here , the encrypted text is transformed to bytes using the same crypt string to binary function , and after that it goes into second stage of decryption .\nlet\u0026rsquo;s try to apply the same process on the text \u0026ldquo;IAAA\u0026hellip;\u0026rdquo;, and see what we got.\nin order to do that , we should examine the register where the input parameter is passed to function. and then replace the address of the original encrypted text with the address of the text \u0026ldquo;IAAA\u0026hellip;\u0026rdquo;\naddress of \"IAAA\"\nnow , we need to just modify the value of rcx register\nhere we got the data!\nit seems that the program decrypted the text with two different approaches and compared them to each other\nlet\u0026rsquo;s confirm this by getting the sha256 of the resulting data -\u0026gt;\n\u0026#34;W0rmy_Th0ught_1t_w4s_cl3ver_to_use_th3_r1ch_head3r_\u0026#34; sha256 hash\nso yes it does\nnow it is straightforward XOR decryption-\u0026gt;\ndef get_key(input):\rT=\u0026#34;W0rmy_Th0ught_1t_w4s_cl3ver_to_use_th3_r1ch_head3r_\u0026#34;\rfor c in range(len(input)):\r#print(\u0026#34;counter\u0026#34;,c)\rkey=chr(ord(T[c])^(input[c]))\rprint(key,end=\u0026#34;\u0026#34;)\rfinal_stansoframion=\u0026#34;W0rmy_Th0ught_1t_w4s_cl3ver_to_use_th3_r1ch_head3r_\u0026#34;\rdata = [\r0x20, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x27, 0x1A, 0x01,\r0x16, 0x0F, 0x46, 0x03, 0x6F, 0x43, 0x19, 0x26, 0x46, 0x47,\r0x01, 0x6E, 0x00, 0x04, 0x1D, 0x01, 0x55, 0x00, 0x32, 0x0D,\r0x5E, 0x2C, 0x07, 0x42, 0x06, 0x37, 0x5A, 0x1F, 0x03, 0x2D,\r0x1F, 0x48, 0x52, 0x1B, 0x2D, 0x59, 0x06, 0x09, 0x4A, 0x44,\r0x42, 0x2D\r]\r#print(len(data))\r#print(len(final_stansoframion))\rget_key(data) w0rmy1sr1ch.w0rmy1sr1ch.w0rmy1sr1ch.w0rmy1sr1ch.w0r\nEGCTF{W0rmy_Th0ught_1t_w4s_cl3ver_to_use_th3_r1ch_head3r_SM512-m$$bIph}\n","parent":"Ctfs Writeups","permalink":"/blog/ctfs-writeups/3/","section":"blog","summary":"I have participated along with my awesome team 0xD4WN and ranked fifth\nHere are the solutions to two reverse challenges, phantime and millionaire [REV][phantime] We are given a PE file\nDetect it easy\n","title":"EG-CERT Ctf 2025 Qualification"},{"content":"I have participated with my Team 0xWraith, and was able to clear all reverse engineering challenges. Here are the solutions to them..\n[REV][Starwars] We are given a game with 3 files\nBy inspecting the exe file in DIE, we get this\nIt is a game made with the GameMaker engine Upon opening it, you will be controlling a dart that shoots circles, and your score will increase at the top left.\nThe idea here is that the win condition is not implemented, so let\u0026rsquo;s dig deeper to see what we can do.\nThe main logic, objects, functions, variables, and fonts of the game are in a file called data.win, and there is an open-source tool called UndertaleModTool that enables you to decompile the game.\nUndertaleModTool\nopening the data.win file -\u0026gt;\nBy exploring the functions, I saw that one\nThis is the win function obviously the flag drawing is in the draw_text function, so we have to move this code in the obj_game events to be triggered And then we see the flag\nCONCTF{WH4t_4_hAck3r_y0u_ar3}\n[REV][Yoru] We are given a PE file as shown\nUpon executing it, we are prompted to a window with two input fields :\nLet\u0026rsquo;s explore the file in IDA to see what is going on\nWe got so many useless functions for our analysis\nBut since we saw text on the window like {\u0026ldquo;wrong\u0026rdquo;,\u0026ldquo;length\u0026rdquo;,\u0026ldquo;Username\u0026rdquo;} and so on, it is probably hard-coded in the program, and if we use the search text feature in IDA, we will spot an important function in IDA, which checks for username and password.\nThe function does simple XOR encryption with our input and compares the result to hard hard-coded expected data The login info is:\nusername: \u0026ldquo;Did_you_really\u0026rdquo;\npassword:\u0026ldquo;fall_for_my_trap?_xD\u0026rdquo;\nAnd we got that window mentioning that pc name is wrong, that could be a hint or something.\ni found this function that get my computer name and inputs it along with a key (0x7ff7ea47a000) to an encryption function, and then compares the result to hardcoded data in 0x7FF7EA47A010\naddress\nby searching inside this encryption function, we find it is the AES_ECB algorithm Since we have the key and the ciphertext, we can decrypt it to obtain the plain text which is the computer name that was supposedly intended, but we still do not know why we need that computer name, any way let\u0026rsquo;s continue\nfrom Crypto.Cipher import AES\rkey = bytes([\r0x2B, 0x7E, 0x15, 0x16,\r0x28, 0xAE, 0xD2, 0xA6,\r0xAB, 0xF7, 0x15, 0x88,\r0x09, 0xCF, 0x4F, 0x3C\r])\rresult_data= bytes([\r0x4F, 0x03, 0xE8, 0xE7,\r0x76, 0x8B, 0x0E, 0x8B,\r0x29, 0x25, 0x63, 0x62,\r0x45, 0x66, 0xD5, 0x1F\r])\rc= AES.new(key, AES.MODE_ECB)\rp= c.decrypt(result_data)\rprint(p) C0nN3ctEd_aDmi1n\nby digging deeper in the program, we found that flag check function it takes the pc name as a key and encrypts bytes, and then compares it to the true data.\nThis is a straightforward RC4 decryption:\ndef rc4(input_bytes: bytes, key: bytes) -\u0026gt; bytes:\r# Initialize S array like in the binary (256..511)\rS = list(range(256)) # This corresponds to v5[256..511]\rkeylen = len(key)\r# Copy key into v5[0..255]\rv = [key[i % keylen] for i in range(256)]\r# KSA (key scheduling)\rj = 0\rfor i in range(256):\rj = (j + v[i] + S[i]) \u0026amp; 0xFF\rS[i], S[j] = S[j], S[i]\r# PRGA (stream generation \u0026amp; XOR)\rout = bytearray()\ri = 0\rj = 0\rfor b in input_bytes:\ri = (i + 1) \u0026amp; 0xFF\rj = (j + S[i]) \u0026amp; 0xFF\rS[i], S[j] = S[j], S[i]\rK = S[(S[i] + S[j]) \u0026amp; 0xFF]\rout.append(b ^ K)\rreturn bytes(out)\rif __name__ == \u0026#34;__main__\u0026#34;:\rcipher_bytes = bytes([\r0x8F, 0x06, 0xC0, 0x3D, 0x54, 0x9C, 0xFA, 0x26,\r0xCF, 0x14, 0xC8, 0xBC, 0x1D, 0xC7, 0x3B, 0x1B,\r0x9C, 0xE4, 0xD5, 0xDD, 0x1B, 0x9C, 0x61, 0x0B,\r0xD8, 0x8B, 0xAF, 0xD4, 0x3D, 0x5F, 0x25, 0x00,\r0xA0, 0xFA, 0xCA, 0xED, 0xD0, 0xA2, 0x6A, 0x7A,\r0x71, 0x89, 0x3B, 0xD9])\rkey = b\u0026#34;C0nN3ctEd_aDmi1n\u0026#34;\rresult = rc4(cipher_bytes, key)\rprint(result) CONCTF{c0NNect3d_Successfully_T0_Th3_CTF_:D}\n[REV][Roblox Active Developer] We are given a luac file, we will use luadec to decompile it.\nWe see many dummy function that has nothing to do with the flag, but again, we will search by words like {\u0026ldquo;flag\u0026rdquo;,\u0026ldquo;correct\u0026rdquo;,\u0026ldquo;wrong\u0026rdquo;}.\nAnd we get this function\nio.write(\u0026#34;Enter flag: \u0026#34;) local r23_0 = r6_0(io.read(\u0026#34;*l\u0026#34;) or \u0026#34;\u0026#34;) local r24_0 = r15_0() local r26_0 = r20_0(r23_0, r24_0, r16_0(r24_0)) local r27_0 = #r26_0 == #r21_0 if r27_0 then for r31_0 = 1, #r26_0, 1 do if r26_0[r31_0] ~= r21_0[r31_0] then r27_0 = false break end end end if r27_0 then print(\u0026#34;[+] Correct! You solved it.\u0026#34;) else print(\u0026#34;[-] Nope.\u0026#34;) end Note that in that weird language, a \u0026lsquo;#\u0026rsquo; before a var means the length of the data IN the var.\nThe function seems to do some encryption to our input (r23_0) and compare the result to some data, which is r21_0.\nThe target_bytes (r21_0) are :\nciphertext = [250, 114, 60, 118, 65, 181, 249, 18, 67, 31, 28, 124, 135, 132, 173, 161, 183, 49, 71, 88, 22, 212, 47, 194, 9, 127, 177, 61, 8, 188, 53, 224, 47, 15, 243, 226, 43, 88, 249, 232, 84, 26, 226, 176, 221, 64, 202, 223] let\u0026rsquo;s see what r15_0 has\u0026hellip;\nby extracting all needed functions for r15_0, which are: r11,r5,r12,and the r14_0 variable and running it, we got that array:\nbytes:\r[1] = 131\r[2] = 73\r[3] = 49\r[4] = 35\r[5] = 131\r[6] = 228\r[7] = 99\r[8] = 178\r[9] = 223\r[10] = 168\r[11] = 84\r[12] = 165\r[13] = 118\r[14] = 83\r[15] = 178\r[16] = 67 And here is the complete code:\nlocal function r11_0(r0_1012, r1_1012)\r-- line: [3058, 3065] id: 1012\rlocal r2_1012 = r1_1012 or 2166136261\rfor r6_1012 = 1, #r0_1012, 1 do\rr2_1012 = (r2_1012 ~ r0_1012[r6_1012]) * 16777619 \u0026amp; 4294967295\rend\rreturn r2_1012\rend\rlocal function r5_0(r0_1006, r1_1006)\r-- line: [3018, 3021] id: 1006\rr1_1006 = r1_1006 \u0026amp; 31\rreturn (r0_1006 \u0026lt;\u0026lt; r1_1006 | r0_1006 \u0026gt;\u0026gt; 32 - r1_1006) \u0026amp; 4294967295\rend\rlocal function r12_0(r0_1013)\r-- line: [3067, 3072] id: 1013\rr0_1013 = r0_1013 ~ r0_1013 \u0026lt;\u0026lt; 13 \u0026amp; 4294967295\rr0_1013 = r0_1013 ~ r0_1013 \u0026gt;\u0026gt; 17 \u0026amp; 4294967295\rr0_1013 = r0_1013 ~ r0_1013 \u0026lt;\u0026lt; 5 \u0026amp; 4294967295\rreturn r0_1013 \u0026amp; 4294967295\rend\rlocal r14_0 = {\r99, 188, 92, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118\r, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192\r, 183, 253, 147, 38, 54, 63, 247, 140, 52, 165, 229, 241, 113, 216, 49, 21\r, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 175, 150, 117\r, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 43, 47, 42, 132\r, 83, 209, 0, 237, 32, 252, 161, 91, 122, 203, 190, 57, 74, 76, 88, 206\r, 209, 239, 170, 237, 32, 252, 185, 91, 190, 203, 190, 57, 74, 76, 88, 206\r, 208, 238, 66, 204, 233, 186, 101, 205, 132, 54, 226, 8, 133, 125, 188, 15\r, 9, 101, 44, 28, 29, 110, 84, 170, 82, 59, 214, 25, 222, 47, 41, 25\r, 97, 129, 79, 220, 20, 20, 144, 26, 74, 16, 170, 20, 223, 43, 10, 219\r, 224, 50, 56, 10, 73, 6, 36, 82, 194, 163, 121, 211, 25, 106, 228, 121\r, 231, 5, 35, 109, 133, 250, 78, 234, 108, 86, 101, 122, 124, 122, 174, 8\r, 186, 120, 37, 46, 28, 166, 181, 200, 232, 221, 116, 223, 148, 31, 139, 138\r, 112, 124, 37, 93, 72, 3, 232, 110, 1, 84, 101, 29, 205, 115, 65, 46\r, 225, 240, 152, 17, 14, 31, 246, 71, 107, 85, 155, 89, 90, 213, 187, 22\r, 140, 161, 137, 13, 191, 230, 163, 96, 65, 153, 45, 47, 73, 84, 187, 186\r} -- paste the table definition\r-- Copy r15_0 function\rfunction r15_0()\r-- line: [6107, 6149] id: 2014\rlocal r0_2014 = {\r108,\r117,\r97\r}\rlocal r1_2014 = {\r45,\r114,\r51,\r118\r}\rlocal r2_2014 = {\r45,\r99,\r104,\r97,\r108,\r108,\r101,\r110,\r103,\r101\r}\rlocal r3_2014 = {\r33\r}\rlocal r4_2014 = {}\rfor r8_2014, r9_2014 in ipairs({\rr0_2014,\rr1_2014,\rr2_2014,\rr3_2014\r}) do\rfor r13_2014 = 1, #r9_2014, 1 do\rr4_2014[#r4_2014 + 1] = r9_2014[r13_2014]\rend\rend\rlocal r5_2014 = r11_0(r4_2014)\rlocal r6_2014 = {\r3,\r1,\r4,\r1,\r5,\r9,\r2,\r6,\r5,\r3,\r5,\r8\r}\rfor r10_2014 = 1, #r6_2014, 1 do\rlocal r11_2014 = (r5_2014 ~ r6_2014[r10_2014] * 2654435761 \u0026amp; 4294967295) \u0026amp; 4294967295\rr5_2014 = r5_0(r11_0({\r[1] = r11_2014 \u0026amp; 255,\r[2] = r11_2014 \u0026gt;\u0026gt; 8 \u0026amp; 255,\r[3] = r11_2014 \u0026gt;\u0026gt; 16 \u0026amp; 255,\r[4] = r11_2014 \u0026gt;\u0026gt; 24 \u0026amp; 255,\r}, r11_2014), r6_2014[r10_2014] % 13 + 3)\rend\rlocal r7_2014 = r5_2014 ~ 2779096485\rlocal r8_2014 = {}\rfor r12_2014 = 0, 3, 1 do\rr7_2014 = r12_0((r7_2014 ~ 3287226785 + r12_2014 * 2654435761 \u0026amp; 4294967295) \u0026amp; 4294967295)\rlocal r13_2014 = r7_2014 ~ r5_0(r7_2014, r12_2014 + 1) ~ 322420463\rr8_2014[#r8_2014 + 1] = r13_2014 \u0026amp; 255\rr8_2014[#r8_2014 + 1] = r13_2014 \u0026gt;\u0026gt; 8 \u0026amp; 255\rr8_2014[#r8_2014 + 1] = r13_2014 \u0026gt;\u0026gt; 16 \u0026amp; 255\rr8_2014[#r8_2014 + 1] = r13_2014 \u0026gt;\u0026gt; 24 \u0026amp; 255\rend\rfor r12_2014 = 1, 16, 1 do\rr8_2014[r12_2014] = (r8_2014[r12_2014] ~ r14_0[(r8_2014[(r12_2014 - 2) % 16 + 1] + r12_2014 * 17 \u0026amp; 255) + 1]) \u0026amp; 255\rend\rreturn r8_2014\rend\r-- Run it and print the key\rlocal key = r15_0()\rfor i = 1, #key do\rprint(string.format(\u0026#34;[%d] = %d\u0026#34;, i, key[i]))\rend Now we need to see what R16_0 outputs.\nHere is the code of it\nlocal function r12_0(r0_1013)\rr0_1013 = r0_1013 ~ r0_1013 \u0026lt;\u0026lt; 13 \u0026amp; 4294967295\rr0_1013 = r0_1013 ~ r0_1013 \u0026gt;\u0026gt; 17 \u0026amp; 4294967295\rr0_1013 = r0_1013 ~ r0_1013 \u0026lt;\u0026lt; 5 \u0026amp; 4294967295\rreturn r0_1013 \u0026amp; 4294967295\rend\rlocal function r11_0(r0_1012, r1_1012)\rlocal r2_1012 = r1_1012 or 2166136261\rfor r6_1012 = 1, #r0_1012, 1 do\rr2_1012 = (r2_1012 ~ r0_1012[r6_1012]) * 16777619 \u0026amp; 4294967295\rend\rreturn r2_1012\rend\rlocal r14_0 = {\r99, 188, 92, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118,\r202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192,\r183, 253, 147, 38, 54, 63, 247, 140, 52, 165, 229, 241, 113, 216, 49, 21,\r4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 175, 150, 117,\r9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 43, 47, 42, 132,\r83, 209, 0, 237, 32, 252, 161, 91, 122, 203, 190, 57, 74, 76, 88, 206,\r209, 239, 170, 237, 32, 252, 185, 91, 190, 203, 190, 57, 74, 76, 88, 206,\r208, 238, 66, 204, 233, 186, 101, 205, 132, 54, 226, 8, 133, 125, 188, 15,\r9, 101, 44, 28, 29, 110, 84, 170, 82, 59, 214, 25, 222, 47, 41, 25,\r97, 129, 79, 220, 20, 20, 144, 26, 74, 16, 170, 20, 223, 43, 10, 219,\r224, 50, 56, 10, 73, 6, 36, 82, 194, 163, 121, 211, 25, 106, 228, 121,\r231, 5, 35, 109, 133, 250, 78, 234, 108, 86, 101, 122, 124, 122, 174, 8,\r186, 120, 37, 46, 28, 166, 181, 200, 232, 221, 116, 223, 148, 31, 139, 138,\r112, 124, 37, 93, 72, 3, 232, 110, 1, 84, 101, 29, 205, 115, 65, 46,\r225, 240, 152, 17, 14, 31, 246, 71, 107, 85, 155, 89, 90, 213, 187, 22,\r140, 161, 137, 13, 191, 230, 163, 96, 65, 153, 45, 47, 73, 84, 187, 186\r}\rlocal function r16_0(r0_3015)\rlocal r1_3015 = {}\rfor r5_3015 = 1, 16, 1 do\rr1_3015[r5_3015] = r0_3015[17 - r5_3015]\rend\rlocal r2_3015 = r11_0(r1_3015)\rlocal r3_3015 = {}\rfor r7_3015 = 1, 16, 1 do\rr3_3015[r7_3015] = r0_3015[r7_3015] ~ 90\rend\rlocal r4_3015 = r11_0(r3_3015, r2_3015)\rlocal r5_3015 = {}\rlocal r6_3015 = (r2_3015 ~ r4_3015 ~ 3735928559) \u0026amp; 4294967295\rfor r10_3015 = 0, 15, 1 do\rr6_3015 = r12_0(r6_3015 + r10_3015 * 74565 \u0026amp; 4294967295)\rr5_3015[r10_3015 + 1] = (r6_3015 ~ r14_0[(r6_3015 \u0026gt;\u0026gt; (r10_3015 \u0026amp; 31) \u0026amp; 255) + 1] ~ r0_3015[r10_3015 + 1]) \u0026amp; 255\rend\rreturn r5_3015\rend\rlocal r24_0 = {131, 73, 49, 35, 131, 228, 99, 178, 223, 168, 84, 165, 118, 83, 178, 67}\rlocal processed_key = r16_0(r24_0)\rprint(\u0026#34;{\u0026#34; .. table.concat(processed_key, \u0026#34;, \u0026#34;) .. \u0026#34;}\u0026#34;) This gives us\n{178, 41, 50, 242, 52, 21, 116, 232, 122, 160, 110, 13, 188, 35, 137, 56} Finally, we need to know what does r20_0 function does.\nlocal function r20_0(r0_4019, r1_4019, r2_4019)\r-- line: [12219, 12231] id: 4019\rlocal r3_4019 = r10_0(r0_4019, 16)\rlocal r4_4019 = {}\rlocal r5_4019 = r8_0(r2_4019)\rfor r9_4019 = 1, #r3_4019, 16 do\rlocal r10_4019 = {}\rfor r14_4019 = 0, 15, 1 do\rr10_4019[r14_4019 + 1] = r3_4019[r9_4019 + r14_4019]\rend\rlocal r12_4019 = r19_0(r9_0(r10_4019, r5_4019), r1_4019)\rfor r16_4019 = 1, 16, 1 do\rr4_4019[#r4_4019 + 1] = r12_4019[r16_4019]\rend\rr5_4019 = r12_4019\rend\rreturn r4_4019\rend Using AI, it does custom AES-CBC encryption, and here is the decryption script:\nkey = bytes([131, 73, 49, 35, 131, 228, 99, 178, 223, 168, 84, 165, 118, 83, 178, 67])\riv = bytes([178, 41, 50, 242, 52, 21, 116, 232, 122, 160, 110, 13, 188, 35, 137, 56])\rct = bytes([\r250, 114, 60, 118, 65, 181, 249, 18, 67, 31, 28, 124, 135, 132, 173, 161,\r183, 49, 71, 88, 22, 212, 47, 194, 9, 127, 177, 61, 8, 188, 53, 224,\r47, 15, 243, 226, 43, 88, 249, 232, 84, 26, 226, 176, 221, 64, 202, 223\r])\rcipher = AES.new(key, AES.MODE_CBC, iv)\rplaintext = unpad(cipher.decrypt(ct), AES.block_size)\rprint(\u0026#34;FLAG:\u0026#34;, plaintext.decode())\r\u0026#34;\u0026#34;\u0026#34;\r# S-box (r14_0)\rSBOX = [\r99, 188, 92, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118,\r202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192,\r183, 253, 147, 38, 54, 63, 247, 140, 52, 165, 229, 241, 113, 216, 49, 21,\r4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 175, 150, 117,\r9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 43, 47, 42, 132,\r83, 209, 0, 237, 32, 252, 161, 91, 122, 203, 190, 57, 74, 76, 88, 206,\r209, 239, 170, 237, 32, 252, 185, 91, 190, 203, 190, 57, 74, 76, 88, 206,\r208, 238, 66, 204, 233, 186, 101, 205, 132, 54, 226, 8, 133, 125, 188, 15,\r9, 101, 44, 28, 29, 110, 84, 170, 82, 59, 214, 25, 222, 47, 41, 25,\r97, 129, 79, 220, 20, 20, 144, 26, 74, 16, 170, 20, 223, 43, 10, 219,\r224, 50, 56, 10, 73, 6, 36, 82, 194, 163, 121, 211, 25, 106, 228, 121,\r231, 5, 35, 109, 133, 250, 78, 234, 108, 86, 101, 122, 124, 122, 174, 8,\r186, 120, 37, 46, 28, 166, 181, 200, 232, 221, 116, 223, 148, 31, 139, 138,\r112, 124, 37, 93, 72, 3, 232, 110, 1, 84, 101, 29, 205, 115, 65, 46,\r225, 240, 152, 17, 14, 31, 246, 71, 107, 85, 155, 89, 90, 213, 187, 22,\r140, 161, 137, 13, 191, 230, 163, 96, 65, 153, 45, 47, 73, 84, 187, 186\r]\r# Helper functions\rdef r5_0(value, shift):\rshift = shift \u0026amp; 31\rreturn ((value \u0026lt;\u0026lt; shift) | (value \u0026gt;\u0026gt; (32 - shift))) \u0026amp; 0xFFFFFFFF\rdef r18_0(key_array, index):\rresult = 0\rfor i in range(4):\rif index + i \u0026lt; len(key_array):\rresult |= (key_array[index + i] \u0026lt;\u0026lt; (i * 8))\rreturn result \u0026amp; 0xFFFFFFFF\rdef r17_0(input_bytes, round_key):\rresult = []\rfor i in range(8):\rkey_byte = (round_key \u0026gt;\u0026gt; ((i % 4) * 8)) \u0026amp; 0xFF\rxored = (input_bytes[i] ^ key_byte) \u0026amp; 0xFF\rsbox_val = SBOX[xored]\rpos_val = ((i * 29) ^ round_key) \u0026amp; 0xFF\rresult.append((sbox_val + pos_val) \u0026amp; 0xFF)\rreturn result\rdef r9_0(arr1, arr2):\rresult = []\rfor i in range(len(arr1)):\rval1 = arr1[i] if i \u0026lt; len(arr1) else 0\rval2 = arr2[i] if i \u0026lt; len(arr2) else 0\rresult.append((val1 ^ val2) \u0026amp; 0xFF)\rreturn result\rdef r19_0_encrypt(input_block, key):\rleft = input_block[:8]\rright = input_block[8:16]\rround_keys = []\rfor round_num in range(8):\rpacked_key = r18_0(key, (round_num % 12)) # Note: Lua uses 1-based indexing\rxored_key = (packed_key ^ (round_num * 2654435761)) \u0026amp; 0xFFFFFFFF\rround_key = r5_0(xored_key, (round_num + 3) \u0026amp; 31)\rround_keys.append(round_key)\rfor round_num in range(8):\rf_result = r17_0(right, round_keys[round_num])\rnew_left = r9_0(left, f_result)\rleft, right = right, new_left\rreturn left + right\rdef r19_0_decrypt(ciphertext_block, key):\rleft = ciphertext_block[:8]\rright = ciphertext_block[8:16]\rround_keys = []\rfor round_num in range(8):\rpacked_key = r18_0(key, (round_num % 12))\rxored_key = (packed_key ^ (round_num * 2654435761)) \u0026amp; 0xFFFFFFFF\rround_key = r5_0(xored_key, (round_num + 3) \u0026amp; 31)\rround_keys.append(round_key)\rfor round_num in range(7, -1, -1): # 7, 6, 5, 4, 3, 2, 1, 0\rf_result = r17_0(left, round_keys[round_num])\rnew_right = r9_0(right, f_result)\rleft, right = new_right, left\rreturn left + right\rdef decrypt_cbc(ciphertext, key, iv):\rplaintext = []\rprev_block = iv[:]\r# Process each 16-byte block\rfor i in range(0, len(ciphertext), 16):\rblock = ciphertext[i:i+16]\r# Decrypt block with custom cipher\rdecrypted_block = r19_0_decrypt(block, key)\r# XOR with previous ciphertext (CBC)\rplain_block = r9_0(decrypted_block, prev_block)\rplaintext.extend(plain_block)\rprev_block = block\rreturn plaintext\rkey = [131, 73, 49, 35, 131, 228, 99, 178, 223, 168, 84, 165, 118, 83, 178, 67]\riv = [178, 41, 50, 242, 52, 21, 116, 232, 122, 160, 110, 13, 188, 35, 137, 56]\rciphertext = [250, 114, 60, 118, 65, 181, 249, 18, 67, 31, 28, 124, 135, 132, 173, 161, 183, 49, 71, 88, 22, 212, 47, 194, 9, 127, 177, 61, 8, 188, 53, 224, 47, 15, 243, 226, 43, 88, 249, 232, 84, 26, 226, 176, 221, 64, 202, 223]\rplaintext_bytes = decrypt_cbc(ciphertext, key, iv)\rflag_chars = []\rfor byte in plaintext_bytes:\rif 32 \u0026lt;= byte \u0026lt;= 126: # Printable ASCII\rflag_chars.append(chr(byte))\relif byte \u0026lt; 32: # Likely padding\rbreak\rflag = \u0026#39;\u0026#39;.join(flag_chars)\rprint(\u0026#34;FLAG:\u0026#34;, flag) CONCTF{lu4_w1th_cust0m3_AES_1s_k1nda_kr4zy}\n","parent":"Ctfs Writeups","permalink":"/blog/ctfs-writeups/4/","section":"blog","summary":"I have participated with my Team 0xWraith, and was able to clear all reverse engineering challenges. Here are the solutions to them..\n[REV][Starwars] We are given a game with 3 files\nBy inspecting the","title":"Connectors Ctf 2025 Qualification"},{"content":"","parent":"Pitou","permalink":"/about/","section":"about","summary":"","title":"Abouts"},{"content":"","parent":"Pitou","permalink":"/categories/","section":"categories","summary":"","title":"Categories"},{"content":"","parent":"","permalink":"/","section":"home","summary":"","title":"Pitou"},{"content":"","parent":"Pitou","permalink":"/projects/","section":"projects","summary":"","title":"Projects"},{"content":"","parent":"Pitou","permalink":"/tags/","section":"tags","summary":"","title":"Tags"},{"content":"","parent":"Pitou","permalink":"/blog/","section":"blog","summary":"","title":"Take A l00k"}]